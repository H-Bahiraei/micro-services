package ir.bki.otpservice.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import ir.bki.otpservice.apects.Loggable;
import ir.bki.otpservice.client.NotificationServiceFeign;
import ir.bki.otpservice.exception.BadRequestAlertException;
import ir.bki.otpservice.repository.model.NotificationRequestDto;
import ir.bki.otpservice.repository.model.ResponseDto;
import ir.bki.otpservice.service.redis.StrongAuthService;
import ir.bki.otpservice.service.ELS.ResponseDtoService;
import ir.bki.otpservice.service.kafka.KafkaProducer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
import javax.ws.rs.DefaultValue;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static ir.bki.otpservice.exception.ErrorCodeConstants.*;

/**
 * @author Mahdi Sharifi
 * @version 2022.1.1
 * https://www.linkedin.com/in/mahdisharifi/
 * @since 4/5/2022
 */
@RestController
@Validated
@RequestMapping("/v1/otp")
@Tag(name = "Otp-Token-Controller for handling OTP services", description = "generate/verify/unBlock/ the OTP code")
@Slf4j
//https://developer.redis.com/develop/java/redis-and-spring-course/lesson_2/
public class OtpTokenController {

    private static final String SEPARATOR = ":";
    private final StrongAuthService strongAuthService;  // ??? final
    private final NotificationServiceFeign notificationServiceFeign;

    @Autowired
    private KafkaProducer kafkaProducer;


    @Autowired
    private ResponseDtoService responseDtoService; /// ???

    public OtpTokenController(StrongAuthService strongAuthService, NotificationServiceFeign notificationServiceFeign) {
        this.strongAuthService = strongAuthService;
        this.notificationServiceFeign = notificationServiceFeign;
    }

    @Loggable
    @PostMapping("/mobiles/{mobile-no}/generation")
    @Operation(summary = "Generate And Send OTP code")
    public ResponseEntity<ResponseDto<String>> generateAndSend(

            @Parameter(description = "Mobile number to allocate and send a otp code")
            @PathVariable("mobile-no")
            @Size(min = 11, max = 12, message = "Invalid phone number in Size")
            @Pattern(regexp = "^[0-9]{11,12}$", message = "Invalid phone number in Pattern ")
                    String mobileNo ////HC:989176323629:XtLOANJCKa
            ,
            @Parameter(description = "Pair-Data is generated by client, it should be same in both /generation and /verification services ")
            @RequestHeader("Pair-Data")
                    String pairData //4586209;5522;832784307;894010930;175000000
            ,
            @Parameter(description = "Timeout for valid period ")
            @DefaultValue("120")
            @RequestHeader("Timeout")
            @Max(300)
            @Min(60)
                    Long timeout //120 in seconds
            ,
            @RequestHeader("Otp-Length")
            @Parameter(description = "Otp-Length id length of Otp Code ")
            @Max(8)
            @Min(4)
            @DefaultValue("5")
                    Integer otpLength //5
            ,
            @Parameter(description = "Authorization mobile number ")
            @RequestHeader(value = "Authorization")
                    String authorization
            ,
            @Valid
            @Parameter(description = "message body for send end user")
            @RequestBody
                    NotificationRequestDto messageBodyRequest
            ,
            HttpServletRequest request) throws BadRequestAlertException {

        //            System.out.println("mobileNo = " + mobileNo + ", pairData = " + pairData + ", timeout = " + timeout + ", otpLength = " + otpLength + ", authorization = " + authorization + ", messageBodyRequest = " + messageBodyRequest + ", request = " + request);

        List<String> payload = new ArrayList<>();
        ResponseDto<String> responseDto = new ResponseDto<>(payload);
        responseDto.setTime(LocalDateTime.now() + "");

        long start = System.currentTimeMillis();

        mobileNo = strongAuthService.correctMobileNo(mobileNo);
        if (!mobileNo.substring(0, 2).equals("98"))
            throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                    INVALID_MOBILE_NO, mobileNo, start);


        boolean isMobileBlocked = strongAuthService.isMobileBlock(mobileNo);
//        strongAuthService.deleteFailedAttemptByMobileNo(mobile No)
        if (!isMobileBlocked) {
            String code = strongAuthService.generateCode(otpLength);
            String messageForSend = "کد فعالسازی شما: " + "\n" + code;
            if (messageBodyRequest != null && !"".equals(messageBodyRequest.getMessage()))
                messageForSend = messageBodyRequest.getMessage().replace("${code}", code);
            String randomString = strongAuthService.generateStringRandom(10);
            String clientHashKey = "HC" + SEPARATOR + mobileNo + SEPARATOR + randomString; // This will send to client
            String cacheKey = clientHashKey + SEPARATOR + code;
            strongAuthService.put(cacheKey, pairData); // cache key: HC:09216017504:TylIvJcoQa:66688 pairData: 20000;transfer;application;ib;tr12345
            strongAuthService.expire(cacheKey, Duration.ofSeconds(timeout));
            payload.add(clientHashKey);//Will return to client: HC:989176323629:XtLOANJCKa ; Client must send it in verify request
            NotificationRequestDto notificationRequestDto = new NotificationRequestDto(messageForSend, mobileNo);
//            ResponseDto<String> responseDtoSms = notificationServiceFeign.send(mobileNo, notificationRequestDto);
//            ResponseDto<String> responseDtoSms = notificationServiceFeign.send(notificationRequestDto);
            kafkaProducer.sendMessage(notificationRequestDto.toJSON()); //TODO It is your EDEN
//            log.info("PUT->cacheKey:" + cacheKey + " ;  value: " + pairData);
//            log.info("#responseDtoSms = " + responseDtoSms);
//            if (responseDtoSms != null)
//                payload.add(responseDtoSms.getPayload().get(0));

            responseDto.setPath(request.getMethod() + " "
                    + request.getServletPath());

            Map reqParams = new HashMap<String, String>();
            reqParams.put("Pair-Data", request.getHeader("Pair-Data"));
            reqParams.put("Authorization", request.getHeader("Authorization"));
            reqParams.put("Otp-Length", request.getHeader("Otp-Length"));
            reqParams.put("Timeout", request.getHeader("Timeout"));

            responseDto.setReqParams(reqParams);
            responseDto.setHttpStatus(HttpStatus.CREATED.value());
            responseDto.setMessage("code is sended");
            responseDto.setStatus(0L);
            responseDtoService.createRdtoIndex(responseDto);
            responseDto.setElapsedTime(System.currentTimeMillis() - start);
            return ResponseEntity
                    .status(responseDto.getHttpStatus()).
                    body(responseDto);
        } else {
            throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                    USER_IS_Blocked, "user is blocked", start);
        }
    }

    @Loggable
    @PostMapping("/mobiles/{mobile-no}/verification")
    @Operation(summary = "Verify OTP code")
    public ResponseEntity<ResponseDto<String>> verify(
            @PathVariable("mobile-no") String mobileNo     //989176323629
            , @RequestHeader("Hash-Key") String clientHashKey // HC:989176323629:XtLOANJCKa -> Redis Key:
            , @RequestHeader("Pair-Data") String pairDataRequest //Value(pd) in cache-> 4586209;5522;832784307;894010930;175000000
            , @RequestHeader("Code") String code  //12345
            , @RequestHeader("Authorization") String authorization
            , HttpServletRequest request) throws Exception {
//        log.info("##mobileNo = " + mobileNo + ", clientHashKey = " + clientHashKey + ", pairData = " + pairDataRequest + ", code = " + code + ", request = " + request);
        List<String> payload = new ArrayList<>();
        long start = System.currentTimeMillis();
        ResponseDto<String> responseDto = new ResponseDto<>(payload);
        responseDto.setTime(LocalDateTime.now() + "");

        responseDto.setPath(request.getMethod() + " "
                + request.getServletPath());

        mobileNo = strongAuthService.correctMobileNo(mobileNo);
        if (!mobileNo.substring(0, 2).equals("98"))
            throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                    INVALID_MOBILE_NO, mobileNo, start);

        boolean isblocked = strongAuthService.isMobileBlock(mobileNo);
        if (isblocked) {
            throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                    USER_IS_Blocked, "user is blocked", start);

        } else {
            String cacheKey = clientHashKey + SEPARATOR + code;//HC:989176323629:XtLOANJCKa:12345
            String cacheValue = strongAuthService.get(cacheKey); //HC:989176323629:XtLOANJCKa:12345
//            log.info("cacheKey: " + cacheKey + " ;cacheValue: " + cacheValue);
            if (cacheValue != null) {
                // pairData found in cache
                if (pairDataRequest != null && !"".equals(pairDataRequest)
                        && cacheValue.equals(pairDataRequest)) {


                    responseDto.setHttpStatus(HttpStatus.OK.value());
                    responseDto.setMessage("code is verified");
                    responseDto.setStatus(0L);
                    strongAuthService.del(cacheKey);
                    strongAuthService.deleteFailedAttemptByMobileNo(mobileNo);
                } else {
                    strongAuthService.createFailedAttempt(mobileNo);
                    throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                            Value_mismatch_with_Key, "Value mismatch with Key", start);
                }
            } else {
                strongAuthService.createFailedAttempt(mobileNo);
                throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                        KEY_IS_NOT_VALUABLE, "KEY IS NOT VALUABLE", start);
            }
        }

        Map reqParams = new HashMap<String, String>();
        reqParams.put("Hash-Key", request.getHeader("Hash-Key"));
        reqParams.put("Code", request.getHeader("Code"));
        reqParams.put("Authorization", request.getHeader("Authorization"));
        reqParams.put("Pair-Data", request.getHeader("Pair-Data"));

        responseDto.setReqParams(reqParams);
        responseDtoService.createRdtoIndex(responseDto);
        responseDto.setElapsedTime(System.currentTimeMillis() - start);
        return ResponseEntity.status(responseDto.getHttpStatus()).body(responseDto);

    }

    @Loggable
    @DeleteMapping("/mobiles/{mobile-no}/unblocking")
    @Operation(summary = "Unblock mobile number ")
    public ResponseEntity<ResponseDto<String>> unBlock(
            @PathVariable("mobile-no") String mobileNo     //989176323629
            , @RequestHeader("description") String description
            , HttpServletRequest request) throws Exception {

//        log.info("##mobileNo = " + mobileNo + ", description = " + description);
        List<String> payload = new ArrayList<>();
        long start = System.currentTimeMillis();

        mobileNo = strongAuthService.correctMobileNo(mobileNo);
        if (!mobileNo.substring(0, 2).equals("98"))
            throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                    INVALID_MOBILE_NO, mobileNo, start);


        ResponseDto<String> responseDto = new ResponseDto<>(payload);
        responseDto.setPath(request.getMethod() + " " + request.getRequestURI());

        boolean isblocked = strongAuthService.isMobileBlock(mobileNo);
        if (isblocked) {
            strongAuthService.deleteFailedAttemptByMobileNo(mobileNo);
            responseDto.setHttpStatus(HttpStatus.OK.value());
            responseDto.setMessage("USER IS UNBLOCKED");
            responseDto.setStatus(0L);
        } else {
            throw new BadRequestAlertException(request.getMethod() + "-->" + request.getRequestURI(),
                    USER_IS_NOT_BLOCKED, "USER IS NOT BLOCKED", start);
        }
        responseDtoService.createRdtoIndex(responseDto);
        responseDto.setElapsedTime(System.currentTimeMillis() - start);
        return ResponseEntity.status(responseDto.getHttpStatus()).body(responseDto);
    }


//    @GetMapping("{key}") // TODO Remove on Pro
//    public ResponseEntity<ResponseDto<String>> get(@PathVariable("key") String key, HttpServletRequest request) {
//        List<String> payload = new ArrayList<>();
//        ResponseDto<String> responseDto = new ResponseDto<>(payload);
//        responseDto.setPath(request.getMethod() + " " + request.getRequestURI());
//        payload.add(strongAuthService.get(key));
//        return ResponseEntity.status(responseDto.getHttpStatus()).body(responseDto);
//    }

//    @GetMapping("s/{id}")
//    public ResponseEntity<String> sget(@PathVariable("id") String id) {
//        return ResponseEntity.ok(strongAuthService.get("2", id));
//    }

//    @GetMapping("s/put/h")
//    public ResponseEntity<String> sputh() {
//        System.out.println("####PUT");
//        strongAuthService.put("2", "f", "v");
//        return ResponseEntity.ok("ADDED");
//    }

//next task:
//    @GetMapping("/books/{id}")
//    Book findOne(@PathVariable @Min(1) Long id) { //jsr 303 annotations
//        return repository.findById(id)
//                .orElseThrow(() -> new BookNotFoundException(id));
//    }
}

//    MethodArgumentNotValidException

//ConstraintViolationException



